= Funcatron Architecture and Strategy

This document describes the https://funcatron.org[Funcatron]
architecture and development strategy.

Funcatron is a http://martinfowler.com/bliki/Serverless.html[Serverless]
framework.
It's dead simple: associate a "function" with an event.
Each time the event happens, the function is applied and the
function's return value is returned to the event source.
An event can be an HTTP(S) request, something on an event queue, whatever.

Functions are ephemeral. They exist for the duration of the function call.
Once the function returns a value, all of its state and scope and
everything else about it is assumed to go away.

Scaling this kind of architecture is simple: the more frequently a function
gets applied, the more compute resources are allocated to support the function.

Funcatron, where possible, abstracts away "switched" connections
into events. What does this mean?

Think of https://en.wikipedia.org/wiki/Internet_protocol_suite[TCP/IP].
To a developer, data in and out of a TCP/IP socket appears
to be a switched connection to the machine on the other side.
But, the protocol is implemented as a series of packets that
may not be reliably delivered.

Funcatron uses a message queue, where possible, to transmit
requests. Each request is stateless in that it may be serviced
by a different system than the previous request. All state
associated with request is pushed to databases and caches outside of
the address space where the code that's handling the
request lives. And https://lift.la/blog/lift-state-and-scaling[there's
always state].

There are numerous advantages to event-based architecture:

* Events can be converted into "`switched`" or blocking calls easily,
  but the inverse is not true. Switch architectures rely on polling
  to check for updates or new information.
* Message Queues are mature and well understood. Switch service routers
  like https://github.com/buoyantio/linkerd[linkerd] are newer and less well understood
  by ops.
* There are many kinds of events that do not require an "answer". Switched
  systems imply an answer beyond an ACK that a message was reliably enqueued.
* Event-based architectures are easier to test. Each block in the architecture
  can be tested by sending events and capturing the resulting events. There's
  no need to set up harnesses that simulate or provide the other end of a switch.


## Funcatron Pieces and Packaging

In Funcatron, user code is referred to as Funcs. Funcs are bundled together
along with routing descriptors in a single file that's called a _Func Bundle_.

Initially, Funcatron is focused on associating HTTP endpoints with code. The
routing description for HTTP-focused Func Bundles is written in https://swagger.io[Swagger].

Func Bundles contain all the information necessary to create routes and run
code based on incoming requests. Funcatron supports the following languages:

* Java/JVM (including Scala, Kotlin, Clojure, etc). JVM Func Bundles are packages as 
  http://maven.apache.org/plugins/maven-assembly-plugin/[Assemblies] or an
  http://imagej.net/Uber-JAR[UberJar].
* Python. Python code is packaged up into a https://github.com/pantsbuild/pex[PEX]
  [NOTE]
====
Python support is scheduled for Funcatron 0.2.0
====
* JavaScript. JavaScript code is bundled using https://webpack.github.io/docs/[Webpack] [NOTE]
====
JavaScript support is scheduled for Funcatron 0.3.0
====

Funcatron is broken into a series of pieces:

* Frontend -- the code the recieves the incoming request.
* Message Queue -- the medium of communication among the system components.
* Tron -- the control system that knows what
* Runner -- The code that dequeues requests and runs the function associated with the request.

[plantuml]
----

  browser  -> "Front End": HTTP Reqest
  "Front End" -> "Front End": Consult Route Table
  "Front End" -> "message queue": Packaged HTTP request
  "message queue" -> Runner
  Runner -> Runner: Func application
  "message queue" <-- Runner: HTTP response
  "Front End" <-- "message queue": HTTP response
  browser <-- "Front End": HTTP response

----

In the current implementation, here is the actual technology used:

* Frontend -- http://openresty.org/en/[OpenResty] with Lua scripts that enqueue the requests
  and dequeue the response
* Message Queue -- http://www.rabbitmq.com/[RabbitMQ]  


[plantuml]
----
  openresty -> message_queue: Awake
  message_queue -> Tron: Awake
  message_queue <-- Tron: Route Table
  openresty <-- message_queue: Route Table
----
