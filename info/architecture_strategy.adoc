= Funcatron Architecture and Strategy

This document describes the https://funcatron.org[Funcatron]
architecture and development strategy.

Funcatron is a http://martinfowler.com/bliki/Serverless.html[Serverless]
framework.
It's dead simple: associate a "function" with an event.
Each time the event happens, the function is applied and the
function's return value is returned to the event source.
An event can be an HTTP(S) request, something on an event queue, whatever.

Functions are ephemeral. They exist for the duration of the function call.
Once the function returns a value, all of its state and scope and
everything else about it is assumed to go away.

Scaling this kind of architecture is simple: the more frequently a function
gets applied, the more compute resources are allocated to support the function.

Funcatron, where possible, abstracts away "switched" connections
into events. What does this mean?

Think of https://en.wikipedia.org/wiki/Internet_protocol_suite[TCP/IP].
To a developer, data in and out of a TCP/IP socket appears
to be a switched connection to the machine on the other side.
But, the protocol is implemented as a series of packets that
may not be reliably delivered.

Funcatron uses a message queue, where possible, to transmit
requests. Each request is stateless in that it may be serviced
by a different system than the previous request. All state
associated with request is pushed to databases and caches outside of
the address space where the code that's handling the
request lives. And https://lift.la/blog/lift-state-and-scaling[there's
always state].

There are numerous advantages to event-based architecture:

* Events can be converted into "`switched`" or blocking calls easily,
  but the inverse is not true. Switch architectures rely on polling
  to check for updates or new information.
* Message Queues are mature and well understood. Switch service routers
  like https://github.com/buoyantio/linkerd[linkerd] are newer and less well understood
  by ops.
* There are many kinds of events that do not require an "answer". Switched
  systems imply an answer beyond an ACK that a message was reliably enqueued.
* Event-based architectures are easier to test. Each block in the architecture
  can be tested by sending events and capturing the resulting events. There's
  no need to set up harnesses that simulate or provide the other end of a switch.


== Funcatron Pieces and Packaging

In Funcatron, user code is referred to as Funcs. Funcs are bundled together
along with routing descriptors in a single file that's called a _Func Bundle_.

Initially, Funcatron is focused on associating HTTP endpoints with code. The
routing description for HTTP-focused Func Bundles is written in https://swagger.io[Swagger].

Func Bundles contain all the information necessary to create routes and run
code based on incoming requests. Funcatron supports the following languages:

* Java/JVM (including Scala, Kotlin, Clojure, etc). JVM Func Bundles are packages as
  http://maven.apache.org/plugins/maven-assembly-plugin/[Assemblies] or an
  http://imagej.net/Uber-JAR[UberJar].
* Python. Python code is packaged up into a https://github.com/pantsbuild/pex[PEX]

[NOTE]
====
Python support is scheduled for Funcatron 0.2.0
====
* JavaScript. JavaScript code is bundled using https://webpack.github.io/docs/[Webpack]

[NOTE]
====
JavaScript support is scheduled for Funcatron 0.3.0
====
* CLR (Common Language Runtime). Run .Net assemblies in Mono (scheduled for Funcatron 0.4.0)


== Network

Funcatron has a series of discrete components, all of which are packaged as https://docker.com[Docker]
components:

* Frontend -- the code the recieves the incoming request.
* Message Queue -- the medium of communication among the system components.
* Tron -- the control system that knows what
* Runner -- The code that dequeues requests and runs the function associated with the request.

The components communicate via network as follows:

[plantuml]
----
skinparam handwritten true


() "Upload/Enable" as Operator

() "HTTPS Proxy" as Proxy

node "Message Queue" as MQ

package "Public Facing" {
    [Frontend]
}

node {
    [Tron]
    [Runner]
}


Proxy -> [Frontend] : "HTTP port 80"

[Frontend] <--> MQ : Stomp

[Tron] <--> MQ : AMQP

Note left of [Frontend]: Multiple instances

[Frontend] -> [Runner] : "HTTP port 4000"

[Runner] -> [Tron] : "HTTP port 3000"

Note left of [Runner] : Multiple instances\nAuto-scaled

Note left of [Tron] : One instance

Note left of MQ : Cluster

Note left of Operator : Access to control\nFuncatron cluster


[Runner] <--> MQ : AMQP

Operator -> [Tron] : "HTTP port 3000"
----

In the current implementation, here is the actual technology used:

* Frontend -- http://openresty.org/en/[OpenResty] with Lua scripts that enqueue the requests
  and dequeue the response
* Message Queue -- http://www.rabbitmq.com/[RabbitMQ]
* Tron -- JVM code (Clojure and Java)
* Runner -- JVM code that uses https://en.wikipedia.org/wiki/Java_Classloader[classloaders] to
            load JVM Func Bundles. For other languages, a new process will be kicked off for each
            Func Bundle

### Request Sequence Diagram

Incoming HTTP requests are handled as follows:


[plantuml]
----
skinparam handwritten true

  browser  -> "Front End": HTTP Reqest
  "Front End" -> "Front End": Consult Route Table
  "Front End" -> "message queue": Packaged HTTP request
  "message queue" -> Runner
  Runner -> Runner: Func application
  "message queue" <-- Runner: HTTP response
  "Front End" <-- "message queue": HTTP response
  browser <-- "Front End": HTTP response

----

#### Directly proxied requests (bypass message queue)

Note, the specific route may be marked "`direct`" because the request or response
payload is too big to be reasonably handled by a message queue. In the case of a direct
request, the sequence is:

[plantuml]
----
skinparam handwritten true

  browser  -> "Front End": HTTP Reqest
  "Front End" -> "Front End": Consult Route Table
  "Front End" -> "message queue": Packaged HTTP request headers
  "message queue" -> Runner
  "message queue" <-- Runner: URL for HTTP request
  "Front End" <-- "message queue": URL for HTTP request
  "Front End" -> Runner : Proxied HTTP request
  Runner -> Runner: Func application
  "Front End" <-- Runner : HTTP response
  browser <-- "Front End" : HTTP response

----

In the above example, the message queue is used so that the Runner that
is available to handle the request is the Runner that has the HTTP request
proxied to it. This avoids the Frontend systems needing an up to date
list of available Runners and avoids having different logic for routing direct
and normal requests.

[NOTE]
====
The Frontend code may, in the future (post 0.2.0), look at the `Content-Length` header and
opt to request a direct connection for large request bodies.
====

Dogs and cats can eat catfood!

[plantuml]
----
  openresty -> message_queue: Awake
  message_queue -> Tron: Awake
  message_queue <-- Tron: Route Table
  openresty <-- message_queue: Route Table
----
